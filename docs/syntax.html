<!doctype html>

<html>
<head>
    <title>CSSTree default syntax reference</title>
    <style>
        html,
        body
        {
            height: 100%;
            margin: 0;
            padding: 0;
            border: none;
            font-family: Tahoma, Verdana, Arial, sans-serif;
            font-size: 14px;
            line-height: 1.6;
        }
        body
        {
            display: flex;
        }
        a
        {
            color: #0099DD;
            text-decoration-skip: ink;
        }
        a:hover
        {
            color: #0077BB;
        }

        aside
        {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            width: 280px;
            background: #f0f0f0;
            border-right: 1px solid #DDD;
            box-shadow: 2px 0 5px -3px rgba(0, 0, 0, .26);
        }
        #filter
        {
            border-bottom: 1px solid #DDD;
            box-shadow: 0 0 6px 0 rgba(0, 0, 0, .05);
            position: relative;
            z-index: 9;
            background: white;
            line-height: 1;
            margin-bottom: -1px;
        }
        #filter input
        {
            width: 100%;
            box-sizing: border-box;
            border: none;
            background-color: white;
            margin: 0;
            outline: none;
            padding: 8px 12px;
            font-size: 14px;
            line-height: 1.2;
        }
        #toc
        {
            overflow: auto;
            flex: 1;
        }
        #toc section
        {
        }
        #toc h2
        {
            top: 0px;
            position: sticky;
            padding: 9px 12px;
            line-height: 1;
            font-size: 14px;
            border: 1px solid #DDD;
            border-width: 1px 0;
            background: #F8F8F8;
            opacity: .95;
            text-transform: capitalize;
            margin: 0;
        }
        #toc .count
        {
            background: #E4E4E4;
            font-weight: normal;
            font-size: 85%;
            padding: 2px 4px;
            border-radius: 5px;
        }
        #toc ul
        {
            margin: 8px 0;
            padding: 0 0 0 30px;
        }
        #toc ul.no-matches::after
        {
            content: 'No matches';
            font-size: 12px;
            color: #AAA;
            margin-left: -16px;
        }
        #toc li.mismatch
        {
            display: none;
        }
        #toc .match-entry
        {
            background: white;
            border-bottom: 2px solid orange;
            line-height: 1.2;
            display: inline-block;
            border-radius: 3px;
            padding: 0 1px;
        }

        article
        {
            flex: 1;
            overflow: auto;
            padding: 16px;
            z-index: 10;
        }
        article h1
        {
            margin: 0 0 16px;
            font-weight: normal;
            font-size: 32px;
        }
        article h2
        {
            font-size: 110%;
            font-weight: normal;
        }
        article section:not(.dont-hide-on-match-hover)
        {
            transition: opacity .4s .15s;
        }
        #syntax,
        #syntax-input,
        #syntax-tree
        {
            background: #f8f8f8;
            padding: 10px;
            margin-bottom: 1em;
            border: none;
            box-sizing: border-box;
            width: 100%;
            font: inherit;
        }
        #syntax .match
        {
            background: #FF9;
            white-space: nowrap;
            padding: 2px;
        }
        #syntax-tree
        {
            margin-bottom: 0;
        }
        .match-syntax-visible section:not(.dont-hide-on-match-hover)
        {
            opacity: .1;
        }
        .error
        {
            color: #DD0000;
        }

        .value-input-wrapper
        {
            margin: 2px 0 16px;
            display: flex;
            align-items: baseline;
        }
        .value-input-hint
        {
            display: none;
            font-size: 16px;
            padding: 4px;
            white-space: nowrap;
        }
        .value-is-function-children .value-input-hint
        {
            display: inline-block;
        }
        #value-input
        {
            box-sizing: border-box;
            width: 100%;
            font-family: Tahoma, Verdana, Arial, sans-serif;
            font-size: 16px;
            padding: 4px 2px;
        }
        #value-input-result
        {
            padding: 5px;
            height: 5.5em;
            color: #DD0000;
            font-family: Consolas, Courier New, monospace;
            white-space: pre;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /*#value-input-result.valid:before
        {
            content: 'Value is valid';
            color: #00AA00;
        }*/
        #value-input-result.valid:not(.empty)
        {
            display: none;
        }
        #value-input-result.empty:before
        {
            content: 'Enter a value to test';
            color: #666;
        }

        #value-match-wrapper
        {
            display: none;
            position: relative;
        }
        #value-input-result.valid:not(.empty) + #value-match-wrapper
        {
            display: block;
        }
        #value-match
        {
            font-family: Consolas, Courier New, monospace;
            font-size: 10px;
            white-space: pre;
            max-height: 300px;
            border: 1px solid #E0E0E0;
            border-width: 1px 0;
            overflow: auto;
        }

        #value-match-tree
        {
            overflow: auto;
        }
        #value-match-tree .label:empty
        {
            display: none;
        }
        #value-match-tree:hover .label,
        #value-match-tree.pinned .label
        {
            opacity: .35;
        }
        .match-tree-node
        {
            font-size: 11px;
            display: inline-block;
            flex: 1;
            cursor: default;
        }
        .match-tree-node + .match-tree-node
        {
            margin-left: 2px;
        }
        .match-tree-node > .label
        {
            display: block;
            text-align: center;
            border-top: 1px solid green;
            padding: 1px 6px 4px;
            line-height: 1;
            white-space: nowrap;
        }
        .match-tree-node:hover > .label,
        .match-tree-node.pinned > .label
        {
            opacity: 1 !important;
            background: linear-gradient(to bottom, rgba(0, 255, 0, .1), transparent 75%);
        }
        .match-tree-node > .children
        {
            display: flex;
            align-items: stretch;
        }
        .match-tree-node_ASTNode
        {
            display: block;
        }
        .match-tree-node_ASTNode > .label
        {
            opacity: 1;
            font-size: 14px;
            background: #E0FFE0;
            margin-bottom: 2px;
            margin-left: -2px;
            border: none;
            border-left: 2px solid white;
            padding: 2px 6px;
            line-height: 1.2;
        }
        .match-tree-node_ASTNode:hover > .label,
        .match-tree-node_ASTNode.pinned > .label
        {
            background-color: #D0FFD0;
        }

        #value-match-hover-syntax
        {
            display: none;
            position: absolute;
            margin-top: 22px;
            left: 0;
            right: 0;
            background: white;
            padding: 12px;
            border: 1px solid #CCC;
            box-shadow: 1px 1px 5px rgba(0, 0, 0, .25);
            z-index: 100;
            line-height: 30px;
        }
        .match-syntax-visible #value-match-hover-syntax
        {
            display: block;
        }
        #value-match-hover-syntax .header
        {
            font-size: 12px;
            text-align: center;
            color: #666;
            margin-top: -8px;
        }
        #value-match-hover-syntax .instruction
        {
            opacity: .75;
        }
        #value-match-hover-syntax ul
        {
            margin: 0;
            padding: 0;
            list-style: none;
        }
        #value-match-hover-syntax li
        {
            overflow: hidden;
            line-height: 20px;
            margin-bottom: -7px;
        }
        #value-match-hover-syntax li + li
        {
            z-index: -1;
        }
        #value-match-hover-syntax .syntax
        {
            display: inline-block;
            padding: 15px 6px 6px;
            position: relative;
            overflow: hidden;
        }
        #value-match-hover-syntax li:first-child .syntax
        {
            padding-top: 0;
        }
        #value-match-hover-syntax .lines
        {
            background-color: rgba(255, 255, 255, .65);
        }
        #value-match-hover-syntax li:not(:last-child) .syntax::before
        {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            border: solid #e5e6b5;
            border-width: 0 1px 2px;
        }
        #value-match-hover-syntax .match,
        #value-match-hover-syntax .children-match
        {
            display: inline-block;
            background: #FF9;
            white-space: nowrap;
            outline: 2px solid #FF9;
            outline-width: 2px 1px;
            text-align: center;
        }
        #value-match-hover-syntax .children-match
        {
            background-color: #CCF;
            outline-color: #CCF;
        }
        #value-match-hover-syntax .match > .tail
        {
            display: block;
        }
        #value-match-hover-syntax .match::before
        {
            content: '';
            position: absolute;
            height: 500px;
            width: 2000px;
            transform: translateX(-100%);
            border: solid #e5e6b5;
            border-width: 2px 2px 0 0;
            top: 0;
            z-index: -1;
        }
        #value-match-hover-syntax .match::after
        {
            content: '';
            position: absolute;
            margin-bottom: -500px;
            margin-left: -200px;
            width: 400px;
            z-index: -1;
            background: white;
            height: 500px;
        }

        #usedBy
        {
            overflow: hidden;
        }
        #usedBy .section
        {
            float: left;
            margin-right: 50px;
        }
        #usedBy h4
        {
            margin: 0 0 10px;
        }
        #usedBy ul
        {
            padding-left: 18px;
            margin: 0;
            min-width: 160px;
        }
    </style>
</head>
<body>
    <aside>
        <div id="filter">
            <input type="text" placeholder="Filter" oninput="updateFilter()"/>
        </div>
        <div id="toc">
        </div>
    </aside>
    <article id="main" style="display: none">
        <h1>Name</h1>
        <section class="dont-hide-on-match-hover">
            <h2>Test a value:</h2>
            <div class="value-input-wrapper">
                <span class="value-input-hint" id="value-function-name">fn(</span>
                <input id="value-input" autofocus value="1px 2px linear-gradient(to top, red 1px, rgb(1,2,3))"/>
                <span class="value-input-hint">)</span>
            </div>
        </section>
        <section class="dont-hide-on-match-hover">
            <div id="value-input-result"></div>
            <div id="value-match-wrapper">
                <h2>Match:</h2>
                <div id="value-match-hover-syntax" hidden>
                    <div class="header">Match trace <span class="instruction"></span></div>
                    <div class="trace"></div>
                </div>
                <div id="value-match-tree"></div>
                <div id="value-match" hidden></div>
            </div>
        </section>
        <section>
            <h2>Formal syntax:</h2>
            <input id="syntax-input" placeholder="Syntax is missed" hidden>
            <div id="syntax"></div>
            <div id="syntax-tree"></div>
        </section>
        <section>
            <h2>Used by:</h2>
            <div id="usedBy"></div>
        </section>
    </article>

    <script src="csstree.js"></script>
    <script>
        /* eslint-env browser */
        /* global csstree */
        function escapeHtml(str) {
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function formatName(type, name) {
            switch (SECTION_MAP[type]) {
                case 'Property':
                    return '<\'' + name + '\'>';

                case 'Type':
                    return '<' + name + '>';

                case 'Function':
                    return name + '()';

                default:
                    return name;
            }
        }

        function buildMatchTree(match, stack) {
            function createMatchBlock(type, content, syntaxMatch) {
                var node = document.createElement('div');
                var caption = content || type;

                node.className = 'match-tree-node' + (type ? ' match-tree-node_' + type : '');
                node.innerHTML =
                    '<span class="children"></span>' +
                    '<span class="label">' + caption + '</span>';

                node.querySelector('.label').syntaxMatch = syntaxMatch || null;

                return {
                    node: node,
                    children: node.querySelector('.children')
                };
            }

            function buildNested(items, container) {
                items.forEach(function(item) {
                    this.appendChild(buildMatchTree(item, stack), this.firstChild);
                }, container);
            }

            var syntax = match.syntax || match;
            var result;

            if (match.type === 'ASTNode') {
                switch (match.node.type) {
                    case 'Function':
                        result = createMatchBlock('', '');
                        result.children.appendChild(
                            createMatchBlock('ASTNode', match.node.name + '(', stack.concat(match)).node
                        );
                        if (match.childrenMatch) {
                            buildNested(match.childrenMatch, result.children);
                        }
                        result.children.appendChild(
                            createMatchBlock('ASTNode', ')', stack.concat(match)).node
                        );
                        break;
                    default:
                        result = createMatchBlock('ASTNode', csstree.translate(match.node), stack.concat(match));
                }
            } else {
                result = createMatchBlock(syntax.type, syntax.name ? syntax.type + ':' + syntax.name : '');

                if (match.match) {
                    stack.push(match);
                    buildNested(match.match, result.children);
                    stack.pop();
                }
            }

            return result.node;
        }

        function validateValue() {
            var value = valueInput.value;
            var isEmpty = !/\S/.test(value);
            var match;
            var error;

            try {
                var ast = csstree.parse(value, {
                    context: 'value'
                });

                if (!isEmpty) {
                    match = defaultSyntax.match(currentSyntax, ast);
                }
            } catch (e) {
                error = e.message + (e.sourceFragment ? '\n' + e.sourceFragment() : '');
            }

            if (match) {
                error = match.error;
            }

            valueInputResultEl.classList.toggle('valid', !error);
            valueInputResultEl.classList.toggle('empty', isEmpty);
            valueInputResultEl.innerText = error || '';

            valueInputMatchTreeEl.innerHTML = '';
            valueInputMatchEl.innerHTML = '';
            if (!error && match && match.matched) {
                valueInputMatchEl.innerText = JSON.stringify(match.matched, null, 2);
                valueInputMatchTreeEl.appendChild(buildMatchTree(match.matched, []));
            }
        }

        function decodeParams() {
            var hash = location.hash.substr(1);
            var parts = hash.split('&');
            var ref = parts[0] || '';
            var section = SECTION_MAP[ref.split(':')[0]];
            var name = ref.split(':')[1];
            var from = parts[1] || '';

            return {
                section: section,
                name: name,
                matchType: from.split(':')[0],
                matchName: from.split(':')[1]
            };
        }

        function updateContent(focusValueInput) {
            var params = decodeParams();
            var section = params.section;
            var name = params.name;
            var contentEl = document.querySelector('article');
            var nestedEl = document.querySelector('#syntax-tree');
            var info;

            switch (section) {
                case 'Property':
                    info = defaultSyntax.getProperty(name);
                    currentSyntax = info;
                    break;
                case 'Type':
                    info = defaultSyntax.getType(name);
                    currentSyntax = info;
                    break;
                case 'Function':
                    info = defaultSyntax.functions[name];
                    currentSyntax = info.syntax.children;
                    document.getElementById('value-function-name').innerHTML = info.name + '(';
                    break;
            }

            contentEl.style.display = info ? '' : 'none';
            nestedEl.style.display = 'none';
            valueInput.parentNode.classList.toggle('value-is-function-children', section === 'Function');

            validateValue();
            if (focusValueInput) {
                valueInput.focus();
                valueInput.select();
            }

            if (!name || !info) {
                try {
                    localStorage.removeItem('csstree-syntax');
                } catch(e) {}
                return;
            }

            document.querySelector('h1').innerText = formatName(section, name);

            var syntax = '';
            var syntaxHtml = '';
            var editingEnabled = true;

            if (info.syntax) {
                syntax = cssSyntax.translate(info.syntax);
                syntaxHtml = cssSyntax.translate(info.syntax, false, function(str, node) {
                    if (node.type === 'Type' || node.type === 'Property') {
                        str = '<span style="white-space: nowrap">' + escapeHtml(str) + '</span>';
                    }
                    if (node.type === params.matchType && node.name === params.matchName) {
                        str = '<span class="match">' + str + '</span>';
                    }
                    return str;
                });
            } else if (info.match) {
                syntax = 'generic';
                syntaxHtml = syntax;
                editingEnabled = false;
            }

            syntaxInput.disabled = !editingEnabled;
            if (syntaxInput.value !== syntax) {
                syntaxInput.value = syntax;
            }
            syntaxString.innerHTML = syntaxHtml;

            if (info.syntax) {
                var nested = {};

                cssSyntax.walk(info.syntax, function walk(node) {
                    var nestedSection;
                    var nestedName;
                    var ref;

                    switch (node.type) {
                        case 'Type':
                            nestedName = node.name;
                            ref = nestedName;
                            nestedSection = 'types';
                            break;

                        case 'Property':
                            nestedName = node.name;
                            ref = '\'' + node.name + '\'';
                            nestedSection = 'properties';
                            break;

                        default:
                            return;
                    }

                    if (nestedName === name && nestedSection === section) {
                        return;
                    }

                    var nestedInfo = defaultSyntax[nestedSection] && defaultSyntax[nestedSection][nestedName];

                    if (nestedInfo && !nestedInfo.syntax) {
                        return;
                    }

                    if (nestedInfo) {
                        if (ref in nested === false) {
                            nested[ref] = {
                                section: nestedSection,
                                name: nestedName,
                                syntax: cssSyntax.translate(nestedInfo.syntax)
                            };
                            cssSyntax.walk(nestedInfo.syntax, walk);
                        }
                    } else {
                        nested[ref] = {
                            error: 'missed syntax'
                        };
                    }
                });

                nestedEl.innerHTML = '';
                Object.keys(nested).forEach(function(ref) {
                    var item = document.createElement('div');
                    var info = nested[ref];

                    item.innerHTML = info.error
                        ? '&lt;' + ref + '&gt; = <span class="error">' + info.error + '</span>'
                        : '<a href="#' + info.section + ':' + info.name + '">&lt;' + ref + '&gt;</a> = ' + escapeHtml(info.syntax);

                    nestedEl.appendChild(item);
                });

                if (nestedEl.firstChild) {
                    nestedEl.style.display = '';
                }

            }

            // used by
            var usedBy = syntaxUsage[info.type + ':' + info.name] || {};
            var usedByKeys = Object.keys(usedBy).sort(function(a, b) {
                a = usedBy[a].name;
                b = usedBy[b].name;
                return a > b ? 1 : a < b ? -1 : 0;
            });
            var lists = usedByKeys.reduce(function(result, key) {
                var usage = usedBy[key];
                var html =
                    '<a href="#' + usage.type + ':' + usage.name + '&' + section + ':' + name + '">' +
                        escapeHtml(formatName(usage.type, usage.name)) +
                    '</a>';

                switch (usage.type) {
                    case 'Type':
                        result.Types.push(html);
                        break;
                    case 'Property':
                        result.Properties.push(html);
                        break;
                    case 'Function':
                        result.Functions.push(html);
                        break;
                }

                return result;
            }, {
                Properties: [],
                Types: [],
                Functions: []
            });

            document.getElementById('usedBy').innerHTML =
                Object.keys(lists).some(function(name) {
                    return lists[name].length > 0;
                })
                    ? Object.keys(lists).map(function(name) {
                        if (lists[name].length) {
                            return (
                                '<div class="section">' +
                                    '<h4>' + name + ' (' + lists[name].length + ')</h4>' +
                                    '<ul>' +
                                        lists[name].sort().map(function(item) {
                                            return '<li>' + item + '</li>';
                                        }).join('') +
                                    '</ul>' +
                                '</div>'
                            );
                        }
                      }).join('')
                    : '<span style="color: #888">No syntaxes</span>';
        }

        function updateFilter() {
            if (currentFilter === filterInput.value.trim()) {
                return;
            }

            currentFilter = filterInput.value.trim();
            var filterRx = new RegExp('(' + currentFilter.replace(/[\('\)]/g, '\\$&') + ')', 'i');

            Array.prototype.forEach.call(document.querySelectorAll('#toc li a'), function(link) {
                var name = link.dataset.name;

                if (currentFilter !== '') {
                    if (filterRx.test(name)) {
                        link.innerHTML = name.split(filterRx).map(function(text, idx) {
                            return idx % 2
                                ? '<span class="match-entry">' + escapeHtml(text) + '</span>'
                                : escapeHtml(text);
                        }).join('');
                        link.parentNode.classList.remove('mismatch');
                    } else {
                        link.parentNode.classList.add('mismatch');
                    }
                } else {
                    link.innerText = name;
                    link.parentNode.classList.remove('mismatch');
                }
            });

            Array.prototype.forEach.call(document.querySelectorAll('#toc h2 .count'), function(counter) {
                var list = counter.parentNode.nextSibling;
                var count = list.querySelectorAll('li:not(.mismatch)').length;

                counter.innerText = count;
                counter.style.visibility = count ? 'visible' : 'hidden';
                list.classList.toggle('no-matches', !count);
            });
        }

        function updatePinnedMatchSyntax(pinnedEl) {
            [].slice.call(valueInputMatchTreeEl.parentNode.querySelectorAll('.pinned'))
                .forEach(function(el) {
                    el.classList.remove('pinned');
                });

            valueInputMatchHoverPopupEl.querySelector('.instruction').innerHTML = valueInputMatchHoverPinned
                ? '(click outside trace block to unpin)'
                : '(click to pin trace block)';

            if (valueInputMatchHoverPinned && pinnedEl) {
                var cursor = pinnedEl;
                while (cursor !== valueInputMatchTreeEl.parentNode) {
                    cursor.classList.add('pinned');
                    cursor = cursor.parentNode;
                }
            }
        }

        function buildMatchTrace(hoverSyntax) {
            var mainMatch = hoverSyntax[hoverSyntax.length - 1];
            var matchNode = mainMatch.node;
            var childrenSyntaxes = (mainMatch.childrenMatch || []).map(function(match) {
                return match.syntax;
            });
            var matches = hoverSyntax.slice(0, -1).reverse().map(function(match, idx, array) {
                var syntax = match.syntax || currentSyntax;
                var prevSyntax = idx > 0 ? array[idx - 1].syntax : null;

                switch (syntax.type) {
                    case 'Type':
                        syntax = defaultSyntax.getType(syntax.name).syntax || syntax;
                        break;
                    case 'Property':
                        syntax = defaultSyntax.getProperty(syntax.name).syntax || syntax;
                        break;
                }

                var syntaxStr = cssSyntax.translate(syntax, false, function(str, node) {
                    if (node.type === 'Type' || node.type === 'Property') {
                        str = '<span style="white-space: nowrap">' + escapeHtml(str) + '</span>';
                    }
                    if (node === prevSyntax) {
                        str = '<span class="match"><span class="tail"></span>' + str + '</span>';
                    } else if (childrenSyntaxes.indexOf(node) !== -1) {
                        str = '<span class="children-match">' + str + '</span>';
                    }
                    return str;
                });

                // ignore Group node with single Function node match
                // since it always matched and duplicates following
                if (syntax.type === 'Group' &&
                    syntax.terms.length === 1 &&
                    syntax.terms[0].type === 'Function') {
                    return;
                }

                if (idx === 0) {
                    if (syntax.multiplier && syntax.multiplier.comma && matchNode.type === 'Operator' && matchNode.value === ',') {
                        syntaxStr = syntaxStr.replace(/#({[\d,]+})?$/, '<span class="match">#</span>$1');
                    }
                }

                return (
                    '<li>' +
                        '<span class="syntax">' +
                            '<span class="lines">' +
                                syntaxStr +
                            '</span>' +
                        '</span>' +
                    '</li>'
                );
            });

            return '<ul>' + matches.join('') + '</ul>';
        }

        function setHoverMatchSyntax(hoverSyntax) {
            if (valueInputMatchHoverSyntax !== hoverSyntax) {
                valueInputMatchHoverSyntax = hoverSyntax;
                if (hoverSyntax) {
                    clearTimeout(valueInputMatchHoverTimer);
                    mainEl.classList.add('match-syntax-visible');
                    valueInputMatchHoverPopupEl.querySelector('.trace').innerHTML = buildMatchTrace(hoverSyntax);
                } else {
                    mainEl.classList.remove('match-syntax-visible');
                }
            }
        }

        function findHoverMatchSyntax(cursor) {
            var hoverSyntax = null;

            while (cursor !== null) {
                if (cursor.syntaxMatch) {
                    hoverSyntax = cursor.syntaxMatch;
                    break;
                }
                cursor = cursor.parentNode;
            }

            return hoverSyntax;
        }

        function collectUsage(type, dict) {
            function processDescriptor(descriptor) {
                if (descriptor.syntax !== null) {
                    cssSyntax.walk(descriptor.syntax, {
                        enter: function(node) {
                            if (node.type === 'Type' ||
                                node.type === 'Property' ||
                                node.type === 'Function') {
                                var id = node.type + ':' + node.name;

                                if (!syntaxUsage.hasOwnProperty(id)) {
                                    syntaxUsage[id] = Object.create(null);
                                }

                                syntaxUsage[id][host.type + ':' + host.name] = host;

                                if (node.type === 'Function') {
                                    hostStack.push(host);
                                    host = node;
                                    if (!functionX.has(node) && host.name in defaultSyntax.functions) {
                                        var curSyntax = cssSyntax.translate(defaultSyntax.functions[host.name].syntax);
                                        var newSyntax = cssSyntax.translate(node)

                                        if (curSyntax !== newSyntax) {
                                            console.log([
                                                cssSyntax.translate(defaultSyntax.functions[host.name].syntax),
                                                cssSyntax.translate(node)
                                            ].join('\n'));
                                        }
                                    }
                                    functionX.add(node);
                                    defaultSyntax.functions[host.name] = {
                                        type: node.type,
                                        name: node.name,
                                        syntax: node
                                    };
                                }

                                if (id in visited === false) {
                                    visited[id] = true;
                                    switch (node.type) {
                                        case 'Type':
                                            processDescriptor(defaultSyntax.getType(node.name), false);
                                            break;
                                        case 'Property':
                                            processDescriptor(defaultSyntax.getProperty(node.name), false);
                                            break;
                                    }
                                }
                            }
                        },
                        leave: function(node) {
                            if (node.type === 'Function') {
                                host = hostStack.pop();
                            }
                        }
                    });
                }
            }

            // helps to avoid recursion
            var visited;
            var host;
            var hostStack = [];

            for (var name in dict) {
                visited = Object.create(null);
                host = dict[name];
                hostStack.push(host);
                processDescriptor(host, true);
                hostStack.pop();
            }
        }

        var SECTION_MAP = {
            Property: 'Property',
            Type: 'Type',
            Function: 'Function',
            properties: 'Property',
            types: 'Type',
            functions: 'Function'
        };
        var cssSyntax = csstree.grammar;
        var defaultSyntax = csstree.lexer;
        var brokenMap = defaultSyntax.validate();
        var tocEl = document.querySelector('#toc');
        var mainEl = document.querySelector('#main');
        var valueInput = document.getElementById('value-input');
        var valueInputResultEl = document.getElementById('value-input-result');
        var valueInputMatchEl = document.getElementById('value-match');
        var valueInputMatchTreeEl = document.getElementById('value-match-tree');
        var valueInputMatchHoverPopupEl = document.getElementById('value-match-hover-syntax');
        var valueInputMatchHoverTimer = null;
        var valueInputMatchHoverSyntax = null;
        var valueInputMatchHoverPinned = false;
        var filterInput = document.querySelector('#filter > input');
        var syntaxInput = document.querySelector('#syntax-input');
        var syntaxString = document.querySelector('#syntax');
        var currentFilter = '';
        var currentSyntax;
        var syntaxUsage = {};
        var functionX = new Set();

        defaultSyntax.functions = {};

        collectUsage('Property', defaultSyntax.properties);
        collectUsage('Type', defaultSyntax.types);

        valueInput.addEventListener('input', function() {
            valueInputMatchHoverPinned = false;
            validateValue();
            setHoverMatchSyntax(null);
            updatePinnedMatchSyntax();
            localStorage.setItem('csstree-syntax', JSON.stringify({
                hash: location.hash,
                value: valueInput.value
            }));
        });
        syntaxInput.addEventListener('input', function() {
            var ref = location.hash.substr(1);
            var section = ref.split(':')[0];
            var name = ref.split(':')[1];

            switch (section) {
                case 'Property':
                    defaultSyntax.addProperty_(name, syntaxInput.value);
                    updateContent();
                    break;
                case 'Type':
                    defaultSyntax.addType_(name, syntaxInput.value);
                    updateContent();
                    break;
            }
        });
        valueInputMatchTreeEl.addEventListener('mouseenter', function(e) {
            setHoverMatchSyntax(findHoverMatchSyntax(e.target));
            updatePinnedMatchSyntax(e.target);
        }, true);
        valueInputMatchTreeEl.addEventListener('mouseleave', function(e) {
            clearTimeout(valueInputMatchHoverTimer);
            if (!valueInputMatchHoverPinned) {
                valueInputMatchHoverTimer = setTimeout(function() {
                    setHoverMatchSyntax(null);
                }, 100);
            }
        }, true);
        document.addEventListener('click', function(e) {
            if (valueInputMatchHoverPopupEl.contains(e.target)) {
                return;
            }

            var matchSyntax = findHoverMatchSyntax(e.target);

            if (matchSyntax) {
                valueInputMatchHoverPinned = !valueInputMatchHoverPinned;
            } else {
                valueInputMatchHoverPinned = false;
            }

            setHoverMatchSyntax(matchSyntax);
            updatePinnedMatchSyntax(e.target);
        }, true);

        ['properties', 'types', 'functions'].forEach(function(section) {
            var sectionEl = document.createElement('section');
            var headerEl = document.createElement('h2');
            var listEl = document.createElement('ul');
            var brokenCount = 0;

            Object.keys(defaultSyntax[section]).sort().forEach(function(name) {
                var broken = brokenMap && brokenMap[section] ? brokenMap[section].indexOf(name) !== -1 : false;
                var itemEl = document.createElement('li');
                var linkEl = document.createElement('a');
                var caption = formatName(section, name);

                brokenCount += broken;
                linkEl.href = '#' + SECTION_MAP[section] + ':' + name;
                linkEl.className = broken ? 'error' : '';
                linkEl.setAttribute('data-name', caption);
                linkEl.appendChild(document.createTextNode(
                    caption
                ));

                itemEl.appendChild(linkEl);
                listEl.appendChild(itemEl);
            });

            headerEl.innerHTML =
                section +
                ' <span class="count">' + listEl.childNodes.length + '</span>' +
                (brokenCount ? ' <span class="error"><small>[broken:' + brokenCount + ']</small></span>' : '');
            sectionEl.appendChild(headerEl);
            sectionEl.appendChild(listEl);

            tocEl.appendChild(sectionEl);
        });

        (function() {
            try {
                var last = JSON.parse(localStorage.getItem('csstree-syntax'));
                if (last.hash === location.hash) {
                    valueInput.value = last.value;
                }
            } catch(e) {
                localStorage.removeItem('csstree-syntax');
            }
        })();

        window.addEventListener('hashchange', updateContent.bind(null, true), false);
        updateContent(true);
        updateFilter();
    </script>

    <script>
        if (/^csstree.github.io$/i.test(location.host)) {
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-84136412-1', 'auto');
            ga('send', 'pageview');
        }
    </script>
</body>
</html>
